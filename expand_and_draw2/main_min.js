"use strict"; const ps_input = document.getElementById("ps_input"), ps_braket = document.getElementById("ps_braket"), ps_name = document.getElementById("ps_name"), ps_expand = document.getElementById("ps_expand"), margin_top_node = 20, margin_right_node = 20, Seq2Pair = e => { if (0 === e.length) return [0, 0]; const t = isNaN(e[0]) ? 0 : e[0]; if (1 === e.length) return [t, 0]; return [t, isNaN(e[1]) ? 0 : e[1]] }, Str2PS = e => e.slice(1, -1).split(")(").map((e => Seq2Pair(e.split(",").map((e => parseInt(e)))))), PS2Str = e => "(" + e.map((e => e[0] + "," + e[1])).join(")(") + ")", ExpandNormalPairSeq = (e, t) => { if (0 === e.length) return e; const n = t => { let n = t - 1; for (; n >= 0 && e[n][0] >= e[t][0];)--n; return n }; if (-1 === n(e.length - 1)) return e.slice(0, -1); const r = [...Array(e.length)].map(((e, t) => n(t))), l = t => { let n = r[t]; for (; n >= 0 && e[n][1] >= e[t][1];)n = r[n]; return n }; if (-1 === l(e.length - 1)) { const n = r[e.length - 1], l = e.slice(n, -1); let a = e.slice(0, n); for (let e = 0; e < t; ++e)a = a.concat(l); return a } const a = l(e.length - 1), s = e.slice(a, -1); let c = e.slice(0, a); const p = e[e.length - 1][0] - e[a][0]; for (let e = 0; e < t; ++e)c = c.concat(s.map((t => [t[0] + p * e, t[1]]))); return c }, ExpandWeakSubspeciesPairSeq = (e, t) => { if (0 === e.length) return e; const n = t => { let n = t - 1; for (; n >= 0 && e[n][0] >= e[t][0];)--n; return n }; if (-1 === n(e.length - 1)) return e.slice(0, -1); const r = [...Array(e.length)].map(((e, t) => n(t))), l = t => { let n = r[t]; for (; n >= 0 && e[n][1] >= e[t][1];)n = r[n]; return n }; if (-1 === l(e.length - 1)) { const n = r[e.length - 1], l = e.slice(n, -1); let a = e.slice(0, n); for (let e = 0; e < t; ++e)a = a.concat(l); return a } const a = [...Array(e.length)].map(((e, t) => l(t))), s = a[e.length - 1], c = e.slice(s, -1); let p = e.slice(0, s); const i = e[e.length - 1][0] - e[s][0], o = e[e.length - 1][1] - e[s][1] - 1, u = e => e === s ? 1 : e > s ? u(a[e]) : 0; for (let e = 0; e < t; ++e)p = p.concat(c.map(((t, n) => [t[0] + i * e, t[1] + o * u(n + s) * e]))); return p }, ExpandWeakHyperPairSeq = (e, t) => { if (0 === e.length) return e; const n = t => { let n = t - 1; for (; n >= 0 && e[n][0] >= e[t][0];)n--; return n }; if (-1 === n(e.length - 1)) return e.slice(0, -1); const r = [...Array(e.length)].map(((e, t) => n(t))), l = t => { let n = r[t]; for (; n >= 0 && e[n][1] >= e[t][1];)n = r[n]; return n }; if (-1 === l(e.length - 1)) { const n = r[e.length - 1], l = e.slice(n, -1); let a = e.slice(0, n); for (let e = 0; e < t; ++e)a = a.concat(l); return a } const a = [...Array(e.length)].map(((e, t) => l(t))), s = [...Array(e.length)].map(((t, n) => -1 === a[n] ? 0 : e[n][1] - e[a[n]][1])); if (1 === s[e.length - 1]) { const n = a[e.length - 1], r = e.slice(n, -1); let l = e.slice(0, n); const s = e[e.length - 1][0] - e[n][0]; for (let e = 0; e < t; ++e)l = l.concat(r.map((t => [t[0] + s * e, t[1]]))); return l } const c = (e => { let t = a[e]; for (; t >= 0 && s[t] >= s[e];)t = a[t]; return t })(e.length - 1), p = e.slice(c, -1); let i = e.slice(0, c); const o = e[e.length - 1][0] - e[c][0], u = e[e.length - 1][1] - e[c][1] - 1, g = e => e === c ? 1 : e > c ? g(a[e]) : 0; for (let e = 0; e < t; ++e)i = i.concat(p.map(((t, n) => [t[0] + o * e, t[1] + u * g(n + c) * e]))); return i }, PSgeqPS = (e, t) => { if (0 === t.length) return !0; if (0 === e.length) return !1; const n = e.map((t => [t[0] - e[0][0], t[1]])), r = t.map((e => [e[0] - t[0][0], e[1]])); for (let l = 0; l < e.length && l < t.length; ++l)if (n[l][0] < r[l][0] || n[l][0] === r[l][0] && n[l][1] < r[l][1]) return !1; return !(e.length < t.length) }, ExpandPorkHydra = (e, t) => { if (0 === e.length) return e; const n = t => { let n = t - 1; for (; n >= 0 && e[n][0] >= e[t][0];)--n; return n }; if (-1 === n(e.length - 1)) return e.slice(0, -1); const r = [...Array(e.length)].map(((e, t) => n(t))), l = t => { let n = r[t]; for (; n >= 0 && e[n][1] >= e[t][1];)n = r[n]; return n }; if (-1 === l(e.length - 1)) { const n = r[e.length - 1], l = e.slice(n, -1); let a = e.slice(0, n); for (let e = 0; e < t; ++e)a = a.concat(l); return a } const a = [...Array(e.length)].map(((e, t) => l(t))), s = e[e.length - 1][1] - e[a[e.length - 1]][1] > 1 ? a[e.length - 1] : (() => { const t = a[a[e.length - 1]]; let n = [a[e.length - 1]]; for (let l = r[a[e.length - 1]]; l > t; l = r[l])a[l] === t && n.push(l); for (let t = 1; t < n.length; ++t)if (!PSgeqPS(e.slice(n[t]), e.slice(n[0]))) return n[t - 1]; return n[n.length - 1] })(), c = e.slice(s, -1); let p = e.slice(0, s); const i = e[e.length - 1][0] - e[s][0], o = e[e.length - 1][1] - e[s][1] - 1, u = e => e === s ? 1 : e > s ? u(a[e]) : 0; for (let e = 0; e < t; ++e)p = p.concat(c.map(((t, n) => [t[0] + i * e, t[1] + o * u(n + s) * e]))); return p }; function setup() { createCanvas(1, 1, document.getElementById("p5_draw_area")), frameRate(5), textAlign(CENTER, CENTER) } function draw() { } const DrawHydra = (e, t) => { let n = []; for (let r = 0; r < e.length; ++r)e[r][0] < n.length ? n[e[r][0]] = r : n.push(r), 0 !== e[r][0] && line(20 * (.5 + n[e[r][0] - 1]), 20 * (t - e[r][0] + 1), 20 * (.5 + r), 20 * (t - e[r][0])); for (let n = 0; n < e.length; ++n)circle(20 * (.5 + n), 20 * (t - e[n][0]), 15), text(e[n][1], 20 * (.5 + n), 20 * (t - e[n][0])) }, ExpandFinalLine = () => { const e = Str2PS(ps_input.value.replace(/\r\n|\r/g, "\n").split("\n").pop()); switch (ps_name.value) { case "Normal Pair Seq": const t = ExpandNormalPairSeq(e, parseInt(ps_braket.value)); ps_input.value = ps_input.value + "\n" + PS2Str(t); break; case "Weak Subspecies Pair Seq": const n = ExpandWeakSubspeciesPairSeq(e, parseInt(ps_braket.value)); ps_input.value = ps_input.value + "\n" + PS2Str(n); break; case "Weak Hyper Pair Seq": const r = ExpandWeakHyperPairSeq(e, parseInt(ps_braket.value)); ps_input.value = ps_input.value + "\n" + PS2Str(r); break; case "Pork Hydra": const l = ExpandPorkHydra(e, parseInt(ps_braket.value)); ps_input.value = ps_input.value + "\n" + PS2Str(l) }background("white"); const t = ps_input.value.replace(/\r\n|\r/g, "\n").split("\n").map((e => Str2PS(e))), n = t.map((e => 1 + Math.max(...e.map((e => e[0]))))), r = Math.max(...t.map((e => e.length))); resizeCanvas(20 * (r + 2), 20 * (n.reduce(((e, t) => e + t), 0) + 2)); let l = 0; for (let e = 0; e < t.length; ++e)l += n[e], DrawHydra(t[e], l) };